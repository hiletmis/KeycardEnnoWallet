import XCTest
@testable import Keycard

final class KeycardTests: XCTestCase {
    func testApplicationInfo() {
        var data: [UInt8] = [0xa4, 0x61, 0x8f, 0x10, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x80, 0x41, 0x04, 0x7b, 0x83, 0xad, 0x6a, 0xfb, 0x12, 0x09, 0xf3, 0xc8, 0x2e, 0xbe, 0xb0, 0x8c, 0x0c, 0x5f, 0xa9, 0xbf, 0x67, 0x24, 0x54, 0x85, 0x06, 0xf2, 0xfb, 0x4f, 0x99, 0x1e, 0x22, 0x87, 0xa7, 0x70, 0x90, 0x17, 0x73, 0x16, 0xca, 0x82, 0xb0, 0xbd, 0xf7, 0x0c, 0xd9, 0xde, 0xe1, 0x45, 0xc3, 0x00, 0x2c, 0x0d, 0xa1, 0xd9, 0x26, 0x26, 0x44, 0x98, 0x75, 0x97, 0x2a, 0x27, 0x80, 0x7b, 0x73, 0xb4, 0x2e, 0x02, 0x02, 0x02, 0x01, 0x02, 0x01, 0x03, 0x8e, 0x00, 0x8d, 0x01, 0x03]
        var appInfo = try! ApplicationInfo(data)
        XCTAssertTrue(appInfo.initializedCard)
        XCTAssertEqual(appInfo.appVersionString, "2.1")
        XCTAssertFalse(appInfo.hasMasterKey)
        XCTAssertTrue(appInfo.hasSecureChannelCapability)
        XCTAssertTrue(appInfo.hasKeyManagementCapability)
        XCTAssertFalse(appInfo.hasCredentialsManagementCapability)
        XCTAssertFalse(appInfo.hasNDEFCapability)
        XCTAssertEqual(appInfo.freePairingSlots, 3)
        XCTAssertEqual(appInfo.instanceUID, [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f])
        XCTAssertEqual(appInfo.keyUID, [])
        
        data = [0xa4, 0x81, 0x81, 0x8f, 0x10, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x80, 0x41, 0x04, 0x7b, 0x83, 0xad, 0x6a, 0xfb, 0x12, 0x09, 0xf3, 0xc8, 0x2e, 0xbe, 0xb0, 0x8c, 0x0c, 0x5f, 0xa9, 0xbf, 0x67, 0x24, 0x54, 0x85, 0x06, 0xf2, 0xfb, 0x4f, 0x99, 0x1e, 0x22, 0x87, 0xa7, 0x70, 0x90, 0x17, 0x73, 0x16, 0xca, 0x82, 0xb0, 0xbd, 0xf7, 0x0c, 0xd9, 0xde, 0xe1, 0x45, 0xc3, 0x00, 0x2c, 0x0d, 0xa1, 0xd9, 0x26, 0x26, 0x44, 0x98, 0x75, 0x97, 0x2a, 0x27, 0x80, 0x7b, 0x73, 0xb4, 0x2e, 0x02, 0x02, 0x02, 0x01, 0x02, 0x01, 0x03, 0x8e, 0x20, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x8d, 0x01, 0x0f]
        
        appInfo = try! ApplicationInfo(data)
        XCTAssertTrue(appInfo.hasMasterKey)
        XCTAssertTrue(appInfo.hasCredentialsManagementCapability)
        XCTAssertTrue(appInfo.hasNDEFCapability)
        XCTAssertEqual(appInfo.keyUID, [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f])
        
        data = [0x80, 0x00]
        appInfo = try! ApplicationInfo(data)
        XCTAssertFalse(appInfo.initializedCard)
        XCTAssertFalse(appInfo.hasSecureChannelCapability)
        XCTAssertTrue(appInfo.hasCredentialsManagementCapability)
        
        data = [0x80, 0x41, 0x04, 0x7b, 0x83, 0xad, 0x6a, 0xfb, 0x12, 0x09, 0xf3, 0xc8, 0x2e, 0xbe, 0xb0, 0x8c, 0x0c, 0x5f, 0xa9, 0xbf, 0x67, 0x24, 0x54, 0x85, 0x06, 0xf2, 0xfb, 0x4f, 0x99, 0x1e, 0x22, 0x87, 0xa7, 0x70, 0x90, 0x17, 0x73, 0x16, 0xca, 0x82, 0xb0, 0xbd, 0xf7, 0x0c, 0xd9, 0xde, 0xe1, 0x45, 0xc3, 0x00, 0x2c, 0x0d, 0xa1, 0xd9, 0x26, 0x26, 0x44, 0x98, 0x75, 0x97, 0x2a, 0x27, 0x80, 0x7b, 0x73, 0xb4, 0x2e]
        appInfo = try! ApplicationInfo(data)
        XCTAssertFalse(appInfo.initializedCard)
        XCTAssertTrue(appInfo.hasSecureChannelCapability)
        XCTAssertTrue(appInfo.hasCredentialsManagementCapability)

    }
    
    func testKeyPath() {
        var path = try! KeyPath("m/44'/60'/0'/1")
        XCTAssertEqual(path.source, DeriveKeyP1.fromMaster)
        XCTAssertEqual(path.data, [0x80, 0x00, 0x00, 0x2C, 0x80, 0x00, 0x00, 0x3C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01])
        
        path = try! KeyPath("../60")
        XCTAssertEqual(path.source, DeriveKeyP1.fromParent)
        XCTAssertEqual(path.data, [0x00, 0x00, 0x00, 0x3C])
        
        path = try! KeyPath("60'/0'/1")
        XCTAssertEqual(path.source, DeriveKeyP1.fromCurrent)
        XCTAssertEqual(path.data, [0x80, 0x00, 0x00, 0x3C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01])

        path = KeyPath(data: [0x80, 0x00, 0x00, 0x2C, 0x80, 0x00, 0x00, 0x3C, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01], source: DeriveKeyP1.fromCurrent)
        XCTAssertEqual(path.description, "./44'/60'/0'/1")
    }
    
    func testMnemonic() {
        let rawData: [UInt8] = [0x03, 0xa3, 0x05, 0x5f, 0x01, 0xb5, 0x06, 0xaa, 0x05, 0x3f, 0x01, 0x81, 0x03, 0x46, 0x05, 0x7c, 0x02, 0x0e, 0x01, 0x59, 0x04, 0xfd, 0x03, 0x17]

        let mnemonic = Mnemonic(rawData: rawData)
        mnemonic.useBIP39EnglishWordlist()
        XCTAssertEqual(mnemonic.toMnemonicPhrase(), "inner program cute stem pony coral hand question dove clinic panic glass")
        XCTAssertEqual(mnemonic.toBinarySeed(), [0x40, 0x32, 0x9e, 0xad, 0x62, 0xf7, 0xc4, 0x6b, 0x5a, 0x84, 0xb7, 0x2b, 0xa3, 0xee, 0xfd, 0x6a, 0x91, 0xc8, 0x22, 0x67, 0xa5, 0xb1, 0x29, 0xfa, 0x88, 0xec, 0x00, 0x2b, 0x59, 0x3d, 0x5a, 0x24, 0xd5, 0xf6, 0x16, 0xaf, 0xd2, 0x08, 0xba, 0x75, 0x4d, 0xeb, 0xcd, 0x66, 0x91, 0x1a, 0x28, 0x9f, 0x1a, 0x76, 0x04, 0x5a, 0x6a, 0x30, 0x87, 0x5b, 0x0e, 0xe7, 0x08, 0x47, 0x87, 0x49, 0x67, 0x5a])
    }
    
    func testRecoverableSignature() {
        let (priv, pub) = Crypto.shared.secp256k1GeneratePair()
        let hash = Crypto.shared.random(count: 32)
        let sig = Crypto.shared.secp256k1Sign(hash: hash, privKey: priv)
        let data: [UInt8] = [0xa0, UInt8(sig.count + pub.count + 2), 0x80, UInt8(pub.count)] + pub + sig
        let recoverableSig = try! RecoverableSignature(hash: hash, data: data)
        XCTAssertEqual(recoverableSig.publicKey, pub)
        XCTAssertEqual(recoverableSig.r.count, 32)
        XCTAssertEqual(recoverableSig.s.count, 32)
    }
    
    func testBIP32KeyPair() {
        let bip32pair = BIP32KeyPair(fromSeed: Crypto.shared.sha256(Crypto.shared.random(count: 32)))
        XCTAssertTrue(bip32pair.isExtended)
        XCTAssertFalse(bip32pair.isPublicOnly)
        XCTAssertEqual(bip32pair.publicKey.count, 65)
        
        let tlv = TinyBERTLV(bip32pair.toTLV())
        XCTAssertNoThrow(try tlv.enterConstructed(tag: 0xa1))
        XCTAssertEqual(try! tlv.readPrimitive(tag: 0x80).count, 65)
        XCTAssertEqual(try! tlv.readPrimitive(tag: 0x81).count, 32)
        XCTAssertEqual(try! tlv.readPrimitive(tag: 0x82).count, 32)
        
        let publicOnly = try! BIP32KeyPair(fromTLV: [0xa1, 0x43, 0x80, 0x41, 0x04, 0x7b, 0x83, 0xad, 0x6a, 0xfb, 0x12, 0x09, 0xf3, 0xc8, 0x2e, 0xbe, 0xb0, 0x8c, 0x0c, 0x5f, 0xa9, 0xbf, 0x67, 0x24, 0x54, 0x85, 0x06, 0xf2, 0xfb, 0x4f, 0x99, 0x1e, 0x22, 0x87, 0xa7, 0x70, 0x90, 0x17, 0x73, 0x16, 0xca, 0x82, 0xb0, 0xbd, 0xf7, 0x0c, 0xd9, 0xde, 0xe1, 0x45, 0xc3, 0x00, 0x2c, 0x0d, 0xa1, 0xd9, 0x26, 0x26, 0x44, 0x98, 0x75, 0x97, 0x2a, 0x27, 0x80, 0x7b, 0x73, 0xb4, 0x2e])
        
        XCTAssertFalse(publicOnly.isExtended)
        XCTAssertTrue(publicOnly.isPublicOnly)
        XCTAssertNil(publicOnly.privateKey)
        XCTAssertNil(publicOnly.chainCode)
        
        let notExtended = try! BIP32KeyPair(fromTLV: [0xa1, 0x23, 0x81, 0x21, 0x00, 0x03, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f])
        
        XCTAssertFalse(notExtended.isExtended)
        XCTAssertFalse(notExtended.isPublicOnly)
        XCTAssertEqual(notExtended.privateKey!.count, 32)
        XCTAssertNil(notExtended.chainCode)
        XCTAssertEqual(notExtended.publicKey.count, 65)
    }
    
    func testSecureChannel() {
        let (priv, pub) = Crypto.shared.secp256k1GeneratePair()
        let secureChannel = SecureChannel()
        secureChannel.generateSecret(pubKey: pub)
        XCTAssertEqual(secureChannel.secret!, Crypto.shared.secp256k1ECDH(privKey: priv, pubKey: secureChannel.publicKey!))
        
        var clientChallenge: [UInt8]? = nil
        var pairing: [UInt8] = []
        let sharedSecret = Crypto.shared.random(count: 32)
        
        let testChannel = TestCardChannel()
        testChannel.callback = { (cmd) in
            if clientChallenge == nil {
                XCTAssertEqual(cmd.ins, SecureChannelINS.pair.rawValue)
                XCTAssertEqual(cmd.p1, PairP1.firstStep.rawValue)
                let cryptogram = Crypto.shared.sha256(sharedSecret + cmd.data)
                clientChallenge = Crypto.shared.random(count: 32)
                return APDUResponse(sw1: 0x90, sw2: 0x00, data: cryptogram + clientChallenge!)
            } else {
                XCTAssertEqual(Crypto.shared.sha256(sharedSecret + clientChallenge!), cmd.data)
                let salt = Crypto.shared.random(count: 32)
                pairing = Crypto.shared.sha256(sharedSecret + salt)
                return APDUResponse(sw1: 0x90, sw2: 0x00, data: [0x03] + salt)
            }
        }
        
        XCTAssertNoThrow(try secureChannel.autoPair(channel: testChannel, sharedSecret: sharedSecret))
        XCTAssertEqual(secureChannel.pairing!.pairingIndex, 3)
        XCTAssertEqual(secureChannel.pairing!.pairingKey, pairing)
    }

    static var allTests = [
        ("testApplicationInfo", testApplicationInfo),
        ("testKeyPath", testKeyPath),
        ("testMnemonic", testMnemonic),
        ("testRecoverableSignature", testRecoverableSignature),
        ("testBIP32KeyPair", testBIP32KeyPair),
        ("testSecureChannel", testSecureChannel)
    ]
}
